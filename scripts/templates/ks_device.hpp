/// {{ device.class_name|lower }}.hpp
///
/// Generated by devgen.
/// DO NOT EDIT.
///
/// (c) Koheron 

#ifndef __{{ device.class_name|upper }}_HPP__
#define __{{ device.class_name|upper }}_HPP__

#include <core/kdevice.hpp>

{% for include in device.includes -%}
#include "{{ include }}"
{% endfor -%}

// #include <core/devices_manager.hpp>

#if KSERVER_HAS_THREADS
#include <mutex>
#endif

namespace kserver {

template<>
class KDevice<{{ device.tag }}> : public KDeviceBase<{{ device.tag }}>
{
  public:
    const device_t kind = {{ device.tag }};
    enum { __kind = {{ device.tag }} };

  public:
    int execute(Command& cmd);
    template<int op> int execute_op(Command& cmd);

    KDevice(KServer *kserver)
    : KDeviceBase<{{ device.tag }}>(kserver)
    {
        init();
    }

    void init();

    const {{ device.objects[0]["type"] }}& get_device() const {
        return *{{ device.objects[0]["name"] }}.get();
    }

    enum Operation {
        {% for operation in device.operations -%}
        {{ operation['tag'] }} = {{ operation['id'] }},
        {% endfor -%}        
        {{ device.tag|lower }}_op_num
    };

#if KSERVER_HAS_THREADS
    std::mutex mutex;
#endif

    {% for object in device.objects -%}
    std::unique_ptr<{{ object["type"] }}> {{ object["name"] }};
    {% endfor -%}

{% for operation in device.operations -%}
struct Argument_{{ operation['name'] }} {
{%- macro print_param_line(arg) %}
        {{ arg["type"] }} {{ arg["name"]}};
{%- endmacro -%}
{% for arg in operation["arguments"] -%}
    {{ arg["type"] }} {{ arg["name"]}};
{% endfor -%}
} args_{{ operation['name'] }};

{% endfor -%}

}; // class KS_{{ device.tag|capitalize }}

} // namespace kserver

#endif //__{{ device.class_name|upper }}_HPP__

