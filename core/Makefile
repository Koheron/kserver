# Makefile for Koheron TCP server
#
# Generated by devgen
# {{ date }}
#
# (c) Koheron

CPUS = $(shell nproc 2> /dev/null || echo 1)
MAKEFLAGS += --jobs=$(CPUS)

# TARGET_HOST:
#    - local For compilation on local machine
#    - armhf For compilation on armhf architecture
#    - armel For compilation on armel architecture 

ADD_DEBUG_FLAGS = false

# Middleware include path
MIDWARE_INC_PATH=middleware

# --------------------------------------------------------------
# Objects to build
# --------------------------------------------------------------

# Objects in KServer
OBJS_KSERVER = core/kserver.o              \
               core/listening_channel.o    \
               core/kserver_commands.o     \
               core/session_manager.o      \
               core/kserver_session.o      \
               core/devices_manager.o      \
               core/peer_info.o            \
               core/commands.o             \
               core/kdevice.o              \
               core/websocket.o            \
               core/gason.o                \
               core/config.o               \
               core/crypto/base64.o        \
               core/crypto/sha1.o          \
               core/kserver_syslog.o       \
               core/socket_interface.o     \
               core/signal_handler.o       \
               core/binary_parser.o
               
# Object in KServer/devices
OBJS_KS_DEV ?= {% for obj in objs_list %} {{ obj }} {% endfor %}

# Objects in Middleware
SRC_MIDWARE = $(shell find middleware -name '*.cpp')
OBJS_MIDWARE = $(subst .cpp,.o, $(SRC_MIDWARE))

# All objects 		
OBJS = $(OBJS_MIDWARE) $(OBJS_KSERVER) $(OBJS_KS_DEV) main.o	
# List of raw source files (all object files, renamed from .o to .c)
SRCS = $(subst .o,.c, $(OBJS), ))

# Executable name
TARGET=kserverd

# --------------------------------------------------------------
# Toolchains
# --------------------------------------------------------------

ifeq ($(TARGET_HOST),armhf)
  CROSS_COMPILE?=arm-linux-gnueabihf-
else ifeq ($(TARGET_HOST),armel)
  CROSS_COMPILE?=arm-linux-gnueabi-
  #CROSS_COMPILE?=arm-xilinx-linux-gnueabi-
else ifeq ($(TARGET_HOST),local)
  CROSS_COMPILE?=
  DEFINES += -DLOCAL
endif

# Main GCC executable (used for compiling and linking)

CC=$(CROSS_COMPILE)gcc
CCPP=$(CROSS_COMPILE)g++

# Use Link Time Optimization
#CC=$(CROSS_COMPILE)gcc -flto
#CCPP=$(CROSS_COMPILE)g++ -flto

# --------------------------------------------------------------
# GCC compiling & linking flags
# --------------------------------------------------------------

DEFINES += -DDEBUG_KSERVER 
#DEFINES += -DRELEASE_KSERVER

CFLAGS= -Wall -Werror -Wno-unknown-pragmas \
        -I$(MIDWARE_INC_PATH) -I$(MIDWARE_INC_PATH)/libraries $(DEFINES)

MFPU = vfpv3 # Better
#MFPU = neon # Less good

# Architecture specific flags
ifeq ($(TARGET_HOST),armhf)
  ARM_FLAGS = -march=armv7-a -mtune=cortex-a9 -mfpu=$(MFPU) -mfloat-abi=hard
  CFLAGS += $(ARM_FLAGS)
else ifeq ($(TARGET_HOST),armel)
  ARM_FLAGS = -march=armv7-a -mtune=cortex-a9
  CFLAGS += $(ARM_FLAGS) -D_GLIBCXX_USE_NANOSLEEP
else ifeq ($(TARGET_HOST),local)
  CFLAGS += -march=native
endif

# Add debug/optimization flags
ifeq ($(ADD_DEBUG_FLAGS),true)
  CFLAGS += -rdynamic -g
  ifeq ($(TARGET_HOST),armhf)
    CFLAGS +=-mapcs-frame
  else ifeq ($(TARGET_HOST),armel)
    CFLAGS +=-mapcs-frame
  endif
else
  CFLAGS += -Os
endif

CPPFLAGS=$(CFLAGS) -std=c++14 -pthread

# --------------------------------------------------------------
# Libraries
# --------------------------------------------------------------

LIBS = -lm # -lpthread -lssl -lcrypto

# --------------------------------------------------------------
# Targets
# --------------------------------------------------------------

# Main Makefile target 'all' - it iterates over all targets listed in $(TARGET)
# variable.
all: $(TARGET)

# Target with compilation rules to compile object from source files
%.o: %.c
	$(CC) -c $(CFLAGS) $< -o $@
	
%.o: %.cpp
	$(CCPP) -c $(CPPFLAGS) $< -o $@

# Makefile target with rules how to link executable for each target from $(TARGET) list.
$(TARGET): $(OBJS)
	$(CCPP) -o $@ $^ $(CPPFLAGS) $(LIBS)

# Clean target - when called it cleans all object files and executables.
clean:
	rm -f $(TARGET) *.o $(OBJS)
