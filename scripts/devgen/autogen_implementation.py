# Generate the implementation template for the device
#
# (c) Koheron

import os
import device as dev_utils
import pprint

def Generate(device, directory):
    filename = os.path.join(directory, device.class_name.lower() + '.cpp')
    f = open(filename, 'w')

    try:
        PrintFileHeader(f, os.path.basename(filename))
        f.write('#include "' + device.class_name.lower() + '.hpp' + '"\n\n')
        f.write('#include <core/commands.hpp>\n')
        f.write('#include <core/kserver.hpp>\n')
        f.write('#include <core/kserver_session.hpp>\n')
        f.write('#if KSERVER_HAS_DEVMEM\n')
        f.write('#include <drivers/lib/dev_mem.hpp>\n')
        f.write('#endif\n')
        f.write('namespace kserver {\n\n')
        f.write("#define THIS (static_cast<" + device.class_name + "*>(this))\n\n")

        for operation in device.operations:
            f.write('/////////////////////////////////////\n')
            f.write('// ' + operation["name"] + '\n\n')
            PrintParseArg(f, device, operation)
            PrintExecuteOp(f, device, operation)

        PrintIsFailed(f, device)
        PrintExecute(f, device)
        f.write('} // namespace kserver\n\n')
        f.close()
    except:
        f.close()
        os.remove(filename)
        raise

def PrintFileHeader(file_id, filename):
    file_id.write('/// ' + filename + '\n')
    file_id.write('///\n')
    file_id.write('/// Generated by devgen. \n')
    file_id.write('/// DO NOT EDIT. \n')
    file_id.write('///\n')
    file_id.write('/// (c) Koheron \n\n')

# -----------------------------------------------------------
# PrintParseArg:
# Autogenerate the parser
# -----------------------------------------------------------

def PrintParseArg(file_id, device, operation):
    file_id.write('template<>\n')
    file_id.write('template<>\n')
    file_id.write('int KDevice<' + device.class_name + ',' + device.name + '>::\n')
    file_id.write('        parse_arg<' + device.class_name + '::' + operation['name'] + '> (const Command& cmd,\n' )
    file_id.write('                KDevice<' + device.class_name + ',' + device.name + '>::\n')
    file_id.write('                Argument<' + device.class_name + '::' + operation['name'] + '>& args)\n' )
    file_id.write('{\n')
    PrintParserCore(file_id, device, operation)
    file_id.write('    return 0;\n')
    file_id.write('}\n\n')

def PrintParserCore(file_id, device, operation):    
    if GetTotalArgNum(operation) == 0:
        return

    packs = build_args_packs(file_id, operation)
    print_req_buff_size(file_id, packs)

    file_id.write('    static_assert(req_buff_size <= cmd.buffer.size(), "Buffer size too small");\n\n');
    file_id.write('    if (req_buff_size != cmd.payload_size) {\n')
    file_id.write('        kserver->syslog.print<SysLog::ERROR>(\" [' + device.name + ' - ' + operation['name'] + '] Invalid payload size. Expected %zu bytes. Received %zu bytes.\\n\", req_buff_size, cmd.payload_size);\n')
    file_id.write('        return -1;\n')
    file_id.write('    }\n\n')
    file_id.write('    constexpr size_t position0 = 0;\n')
    pos_cnt = 0

    for idx, pack in enumerate(packs):
        if pack['family'] == 'scalar':
            file_id.write('    auto args_tuple' + str(idx) + ' = deserialize<position' + str(pos_cnt) + ', cmd.buffer.size(), ')
            print_type_list_pack(file_id, pack)
            file_id.write('>(cmd.buffer);\n')

            for i, arg in enumerate(pack['args']):
                file_id.write('    args.' + arg["name"] + ' = ' + 'std::get<' + str(i) + '>(args_tuple' + str(idx) + ');\n');

            if idx < len(packs) - 1:
                file_id.write('\n    constexpr size_t position' + str(pos_cnt + 1) + ' = position' + str(pos_cnt)
                              + ' + required_buffer_size<')
                pos_cnt += 1
                print_type_list_pack(file_id, pack)
                file_id.write('>();\n')
        elif pack['family'] == 'array':
            array_params = get_std_array_params(pack['args']['type'])
            file_id.write('    args.' + pack['args']['name'] + ' = extract_array<position' + str(pos_cnt)
                          + ', ' + array_params['T'] + ', ' + array_params['N'] + '>(cmd.buffer.data);\n')

            if idx < len(packs) - 1:
                file_id.write('\n    constexpr size_t position' + str(pos_cnt + 1) + ' = position' + str(pos_cnt)
                              + ' + size_of<' + array_params['T'] + ', ' + array_params['N'] + '>;\n')
                pos_cnt += 1
        else:
            raise ValueError('Unknown argument family')
def print_req_buff_size(file_id, packs):
    file_id.write('    constexpr size_t req_buff_size = ');

    for idx, pack in enumerate(packs):
        if pack['family'] == 'scalar':
            if idx == 0:
                file_id.write('required_buffer_size<')
            else:
                file_id.write('                                     + required_buffer_size<')
            print_type_list_pack(file_id, pack)
            if idx < len(packs) - 1:
                file_id.write('>()\n')
            else:
                file_id.write('>();\n')
        elif pack['family'] == 'array':
            array_params = get_std_array_params(pack['args']['type'])
            if idx == 0:
                file_id.write('size_of<')
            else:
                file_id.write('                                     + size_of<')
            file_id.write(array_params['T'] + ', ' + array_params['N'] + '>')
            if idx < len(packs) - 1:
                file_id.write('\n')
            else:
                file_id.write(';\n')
    file_id.write('\n')

def print_type_list_pack(file_id, pack):
    for idx, arg in enumerate(pack['args']):
        if idx < len(pack['args']) - 1:   
            file_id.write(arg['type'] + ', ')
        else:
            file_id.write(arg['type'])

def build_args_packs(file_id, operation):
    ''' Packs the adjacent scalars together for deserialization
        and separate them from the arrays '''
    packs = []
    args_list = []
    for idx, arg in enumerate(operation["arguments"]):
        if not is_std_array(arg['type']):
            args_list.append(arg)
        else: # std::array
            if len(args_list) > 0:
                packs.append({'family': 'scalar', 'args': args_list})
                args_list = []
            packs.append({'family': 'array', 'args': arg})
    if len(args_list) > 0:
        packs.append({'family': 'scalar', 'args': args_list})
    # print pprint.pprint(packs)
    return packs

def is_std_array(arg_type):
    return arg_type.split('<')[0].strip() == 'std::array'

def get_std_array_params(arg_type):
    templates = arg_type.split('<')[1].split('>')[0].split(',')
    return {
      'T': templates[0].strip(),
      'N': templates[1].strip()
    }

def GetTotalArgNum(operation):
    if not dev_utils.IsArgs(operation):
        return 0
    return len(operation['arguments'])

# -----------------------------------------------------------
# ExecuteOp
# -----------------------------------------------------------

def PrintExecuteOp(file_id, device, operation):
    file_id.write('template<>\n')
    file_id.write('template<>\n')

    file_id.write('int KDevice<' + device.class_name + ',' + device.name + '>::\n')
    file_id.write('        execute_op<' + device.class_name + '::' + operation['name'] + '> \n' )
    file_id.write('        (const Argument<' + device.class_name + '::' + operation['name'] + '>& args, SessID sess_id)\n')
    file_id.write('{\n')

    # Load code fragments
    for frag in device.fragments:
        if operation['name'] == frag['name']:
            for line in frag['fragment']:
                file_id.write(line)

    file_id.write('}\n\n')

def PrintIsFailed(file_id, device):
    file_id.write('template<>\n')
    file_id.write('bool KDevice<' + device.class_name + ',' + device.name + '>::is_failed(void)\n')
    file_id.write('{\n')

    for frag in device.fragments:
        if frag['name'] == "IS_FAILED":
            for line in frag['fragment']:
                file_id.write(line)

    file_id.write('}\n\n')

def PrintExecute(file_id, device):
    file_id.write('template<>\n')
    file_id.write('int KDevice<' + device.class_name + ',' + device.name + '>::\n')
    file_id.write('        execute(const Command& cmd)\n' )
    file_id.write('{\n')

    file_id.write('#if KSERVER_HAS_THREADS\n')
    file_id.write('    std::lock_guard<std::mutex> lock(THIS->mutex);\n')
    file_id.write('#endif\n\n')

    file_id.write('    switch(cmd.operation) {\n')

    for operation in device.operations:
        file_id.write('      case ' + device.class_name + '::' + operation["name"] + ': {\n')
        file_id.write('        Argument<' + device.class_name + '::' + operation["name"] + '> args;\n\n')
        file_id.write('        if (parse_arg<' + device.class_name + '::' + operation["name"] + '>(cmd, args) < 0)\n')
        file_id.write('            return -1;\n\n')
        file_id.write('        return execute_op<' + device.class_name + '::' + operation["name"] + '>(args, cmd.sess_id);\n')
        file_id.write('      }\n')

    file_id.write('      case ' + device.class_name + '::' + device.name.lower() + '_op_num:\n')
    file_id.write('      default:\n')
    file_id.write('          kserver->syslog.print<SysLog::ERROR>("' + device.class_name + ': Unknown operation\\n");\n')
    file_id.write('          return -1;\n')
    file_id.write('    }\n')
    file_id.write('}\n\n')
