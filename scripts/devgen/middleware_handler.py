# Generates a device description dictionnary and code fragments 
# from a tagged C++ header file
#
# (c) Koheron

import os
import time
import yaml
import string

from hpp_parser import parse_header, CSTR_TYPES

class MiddlewareHandler:
    def __init__(self, hppfile):
       self.parser =  MiddlewareHppParser(hppfile)

    def generate_device_description_file(self, path):
        ''' Generate the device description dictionnary '''
        d2l_filename = os.path.join(path, self.parser.get_device_name().lower() + '.yaml')
        f = open(d2l_filename, 'w')

        f.write('# Device description file for ' + self.parser.raw_dev_data['name'] + '\n')
        f.write('#\n')
        f.write('# Generated by devgen.\n')
        f.write('# DO NOT EDIT.\n')
        f.write('#\n')
        f.write('# ' + time.strftime("%c") + "\n")
        f.write('# (c) Koheron\n\n')

        yaml.dump(self.parser.device, f, indent=2, default_flow_style=False)
        f.close()

        return d2l_filename

    def get_device_data(self):
        # self.generate_device_description_file('./tmp')
        return self.parser.device

    def get_fragments(self):
        frag_gen = FragmentsGenerator(self.parser)
        return frag_gen.get_fragments()

class MiddlewareHppParser:
    def __init__(self, hppfile):
        devices = parse_header(hppfile)
        self.raw_dev_data = devices[0]
        self.raw_dev_data["includes"] = [os.path.basename(hppfile)];
        self.device = self._get_device()

    def _get_template(self, ret_type):
        tokens = ret_type.split('<')

        if len(tokens) == 2:
            return tokens[1].split('>')[0].strip()
        else:
            return None

    def _get_device(self):
        device = {}
        device['operations'] = []
        device['raw_name'] = self.raw_dev_data['name']
        device['name'] = self.get_device_name()
        device['includes'] = self.raw_dev_data['includes']
        device['objects'] = [{
          'type': self.raw_dev_data['objects'][0]['type'],
          'name': '__' + self.get_device_name().lower()
        }]

        for op in self.raw_dev_data['operations']:
            device['operations'].append(self._format_operation(op))

        return device

    def get_device_name(self):
        ''' Build the device name from the class name '''
        raw_name = self.raw_dev_data['name']
        dev_name = []

        # Check whether there are capital letters within the class name
        # and insert an underscore before them
        for idx, letter in enumerate(raw_name):
            if idx > 0 and letter in list(string.ascii_uppercase):
                dev_name.append('_')

            dev_name.append(letter.upper())

        return ''.join(dev_name)

    def _format_operation(self, op):
        operation = {}
        operation['name'] = op['prototype']['name'].upper()
        operation['raw_name'] = op['prototype']['name']

        if 'flags' in op and len(op['flags']) > 0:
            operation['flags'] = op['flags']

        if op['io_type']['value'] == 'WRITE_ARRAY':
            send_buffer_flag = {
              'name': 'SEND_BUFFER',
              'buffer_name': [op['array_params']['name']['name']]
            }

            if len(op['flags']) > 0:
                operation['flags'].append(send_buffer_flag)
            else:
                operation['flags'] = [send_buffer_flag]

        if len(op['prototype']['params']) > 0:
            if op['io_type']['value'] == 'WRITE_ARRAY':
                array_name_ok = False
                array_length_ok = False

                for param in op['prototype']['params']:
                    param_ptr_toks = param['name'].split('*')

                    if (op['array_params']['name']['src'] == 'param' and
                        len(param_ptr_toks) == 2 and
                        param_ptr_toks[1].strip() == op['array_params']['name']['name']):
                        array_name_ok = True
                    elif (op['array_params']['name']['src'] == 'param' and
                        len(param_ptr_toks) == 1 and
                        param_ptr_toks[0].strip() == op['array_params']['name']['name']):
                        array_name_ok = True
                    else:
                        if (op['array_params']['length']['src'] == 'param' and
                            param['name'] == op['array_params']['length']['length']):
                            array_length_ok = True

                        arg = {}
                        arg['name'] = param['name']
                        arg['type'] = param['type'].strip()
                        self._format_argument(arg)

                        if 'arguments' in operation:
                            operation['arguments'].append(arg)
                        else:
                            operation['arguments'] = [arg]

                if not array_name_ok or not array_length_ok:
                    raise ValueError('write_array arguments not found in function prototype')
            else:
                operation['arguments'] = []

                for param in op['prototype']['params']:
                    arg = {}
                    arg['name'] = param['name']
                    arg['type'] = param['type'].strip()
                    self._format_argument(arg)
                    operation['arguments'].append(arg)

        return operation

    def _format_argument(self, arg):
        if arg['type'][-1:] == '&': # Argument passed by reference
            arg['by_reference'] = True
            arg['type'] = arg['type'][:-2].strip()

        if arg['type'][:5] == 'const':# Argument is const
            arg['is_const'] = True
            arg['type'] = arg['type'][5:].strip()

class FragmentsGenerator:
    def __init__(self, parser):
        self.parser = parser

    def get_fragments(self):
        fragments = []

        for op in self.parser.raw_dev_data['operations']:
            op_name = op['prototype']['name'].upper()
            frag = {}
            frag['name'] = op_name
            frag['fragment'] = self.generate_fragment(op_name)
            fragments.append(frag)

        # Add is_failed fragment 
        frag = {}
        frag['name'] = 'IS_FAILED'
        frag['fragment'] = [self._gen_is_failed_fragment()]
        fragments.append(frag)

        return fragments

    def generate_fragment(self, op_name):
        ''' Generate the fragment of an operation '''
        operation = self._get_operation_data(op_name)
        frag = []

        if operation['io_type']['value'] == 'WRITE':
            frag.append('    ' + self._build_func_call(operation) + ';\n')
            frag.append('    return 0;\n')
        elif operation['io_type']['value'] == 'READ':
            template = self.parser._get_template(operation['prototype']['ret_type'])

            known_types = {'uint32_t', 'unsigned int', 'unsigned long', 'int', 'int32_t', 'bool',
                           'uint64_t', 'unsigned long long', 'float', 'double', 'std::string', 'auto', 'auto&', 'auto &'}

            known_template_types = {'std::vector', 'std::array', 'std::tuple'}

            if operation['prototype']['ret_type'] in known_types:
                frag.append('    return SEND('+ self._build_func_call(operation) + ');\n')
            elif template != None:
                type_base = operation['prototype']['ret_type'].split('<')[0].strip()

                if type_base in known_template_types:
                    frag.append('    return SEND<' + template + '>('
                                + self._build_func_call(operation) + ');\n')
            else:
                raise ValueError('No available interface to send type '
                                 + operation['prototype']['ret_type'])

        elif operation['io_type']['value'] == 'READ_CSTR':
            if operation['prototype']['ret_type'] not in CSTR_TYPES:
                raise ValueError('I/O type READ_CSTR expects a char*. Found '
                                 + operation['prototype']['ret_type'] + '.\n')

            frag.append('    return SEND_CSTR('
                        + self._build_func_call(operation) + ');\n')

        elif operation['io_type']['value'] == 'READ_ARRAY':
            ptr_type = self._get_ptr_type(operation['prototype']['ret_type'])
            remaining = operation['io_type']['remaining']

            if remaining.find('this') >= 0:
                obj_name = self.parser.device['objects'][0]['name']
                member_name = remaining.split('{')[1].split('}')[0].strip()
                member_call = 'THIS->' + obj_name + '.' + member_name
                length = remaining.replace('this{' + member_name + '}', member_call)
            elif remaining.find('arg') >= 0:
                length = ''
                for param in operation['prototype']['params']:
                    if remaining.find(param['name']) >= 0:
                        length = remaining.replace('arg{' + param['name'] + '}', 'args.' + param['name'])
                if length == '': # Length is a constant independent of a parameter
                    length = remaining
            else: # Length is a constant independent of a parameter
                length = remaining

            frag.append('    auto ptr = ' + self._build_func_call(operation) + ';\n')
            frag.append('    return SEND_ARRAY<' + ptr_type + '>(ptr, ' + length + ');\n')

        elif operation['io_type']['value'] == 'WRITE_ARRAY':
            len_name = operation['array_params']['length']['length']

            frag.append('    const uint32_t *data_ptr = RCV_HANDSHAKE(args.' + len_name + ');\n\n')
            frag.append('    if (data_ptr == nullptr)\n')
            frag.append('       return -1;\n\n')
            if (operation['prototype']['ret_type'] == 'uint32_t'
                or operation['prototype']['ret_type'] == 'unsigned int'
                or operation['prototype']['ret_type'] == 'unsigned long'
                or operation['prototype']['ret_type'] == 'int'
                or operation['prototype']['ret_type'] == 'int32_t'
                or operation['prototype']['ret_type'] == 'bool'):
                frag.append('    return SEND<uint32_t>(' + self._build_write_array_func_call(operation) + ');\n')
            else:
                frag.append('    ' + self._build_write_array_func_call(operation) + ';\n\n')
                frag.append('    return 0;\n')

        # self._show_fragment(frag)
        return frag

    def _get_ptr_type(self, ret_type):
        '''Get the pointer type
        Ex. if ret_type is char* it returns char.
        Raise an error if ret_type is not a pointer.
        '''
        tokens = ret_type.split('*')

        # T*
        if len(tokens) == 2:
            return tokens[0].strip()
        # const T*
        elif tokens[0].split(' ')[0].strip() == 'const' and len(tokens) == 2:
            return tokens[0].split(' ')[1].strip()
        else:
            raise ValueError('Return type ' + ret_type + ' is not a pointer')

    def _get_operation_data(self, op_name):
        for op in self.parser.raw_dev_data["operations"]:
            if op["prototype"]["name"].upper() == op_name:
                return op
        raise ValueError("Unknown operation " + op_name)

    def _build_func_call(self, operation):
        obj_name = self.parser.device["objects"][0]["name"]
        func_name = operation["prototype"]["name"]
        call = "THIS->" + obj_name + "." + func_name + "("
        
        for count, param in enumerate(operation["prototype"]["params"]):
            if count == 0:
                call += "args." + param["name"]
            else:
                call += ", args." + param["name"]

        call += ")"
        return call

    def _build_write_array_func_call(self, operation):
        assert operation["io_type"]["value"] == "WRITE_ARRAY"
        len_name = operation["array_params"]['length']['length']
        obj_name = self.parser.device["objects"][0]["name"]
        func_name = operation["prototype"]["name"]
        call = "THIS->" + obj_name + "." + func_name + "("

        for count, param in enumerate(operation["prototype"]["params"]):
            param_ptr_toks = param["name"].split('*')

            if ((operation["array_params"]["name"]["src"] == "param" and
                len(param_ptr_toks) == 2 and
                param_ptr_toks[1].strip() == operation["array_params"]["name"]["name"]) or
                (operation["array_params"]["name"]["src"] == "param" and
                len(param_ptr_toks) == 1 and
                param_ptr_toks[0].strip() == operation["array_params"]["name"]["name"])):

                if count == 0:
                    call += "data_ptr"
                else:
                    call += ", data_ptr"
            elif (operation["array_params"]["length"]["src"] == "param" and
                  param["name"] == operation["array_params"]["length"]["length"]):
                if count == 0:
                    call += "args." + len_name
                else:
                    call += ", args." + len_name
            else:
                if count == 0:
                    call += "args." + param["name"]
                else:
                    call += ", args." + param["name"]

        call += ")"
        return call

    def _show_fragment(self, fragment):
        print ''.join(fragment)

    def _gen_is_failed_fragment(self):
        if "is_failed" in self.parser.raw_dev_data:
            obj_name = self.parser.device["objects"][0]["name"]
            func_name = self.parser.raw_dev_data["is_failed"]["name"]
            return "    return THIS->" + obj_name + "." + func_name + "();\n"
        else:
            return "    return false;\n"
